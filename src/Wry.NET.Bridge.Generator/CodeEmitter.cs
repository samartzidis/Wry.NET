using System.Text;

namespace Wry.NET.Bridge.Generator;

static class CodeEmitter
{
    internal const string ToolName = "BindingGenerator";
    internal const string GeneratedHeader = "// Auto-generated by " + ToolName + ". Do not edit.";

    internal static string GenerateServiceFile(ServiceDef service, Dictionary<string, TypeDef> models)
    {
        var sb = new StringBuilder();
        sb.AppendLine(GeneratedHeader);
        sb.AppendLine("import { call } from \"./runtime\";");

        // Check if any method references a model type
        var usesModels = service.Methods
            .Any(m => ReferencesModel(m.ReturnType, models) ||
                       m.Parameters.Any(p => ReferencesModel(p.Type, models)));
        if (usesModels)
        {
            var modelNames = GetReferencedModelNames(service, models);
            if (modelNames.Count > 0)
            {
                sb.AppendLine($"import type {{ {string.Join(", ", modelNames)} }} from \"./models\";");
            }
        }

        sb.AppendLine();

        foreach (var method in service.Methods)
        {
            var returnTs = TypeMapper.MapTypeToTS(method.ReturnType, models);
            var isVoid = returnTs == "void" ||
                         (TypeMapper.IsTaskType(method.ReturnType) && !method.ReturnType.IsGenericType);

            // Parameter list
            var paramList = string.Join(", ",
                method.Parameters.Select(p => $"{StringHelpers.ToCamelCase(p.Name)}: {TypeMapper.MapTypeToTS(p.Type, models)}"));

            var tsReturn = isVoid ? "Promise<void>" : $"Promise<{returnTs}>";

            sb.AppendLine($"export function {method.Name}({paramList}): {tsReturn} {{");

            // Arguments to pass
            var argList = string.Join(", ",
                method.Parameters.Select(p => StringHelpers.ToCamelCase(p.Name)));

            var callArgs = string.IsNullOrEmpty(argList)
                ? $"\"{service.Name}.{method.Name}\""
                : $"\"{service.Name}.{method.Name}\", {argList}";

            if (isVoid)
                sb.AppendLine($"  return call<void>({callArgs});");
            else
                sb.AppendLine($"  return call<{returnTs}>({callArgs});");

            sb.AppendLine("}");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    internal static string GenerateModelsFile(Dictionary<string, TypeDef> models)
    {
        var sb = new StringBuilder();
        sb.AppendLine(GeneratedHeader);
        sb.AppendLine();

        foreach (var model in models.Values)
        {
            if (model.Kind == TypeDefKind.Enum)
            {
                sb.AppendLine($"export enum {model.Name} {{");
                foreach (var val in model.EnumValues!)
                {
                    sb.AppendLine($"  {val.Name} = {StringHelpers.FormatEnumValue(val.Value)},");
                }
                sb.AppendLine("}");
            }
            else
            {
                var extendsClause = model.BaseTypeName != null ? $" extends {model.BaseTypeName}" : "";
                sb.AppendLine($"export interface {model.Name}{extendsClause} {{");
                foreach (var prop in model.Properties!)
                {
                    var tsType = TypeMapper.MapTypeToTS(prop.Type, models);

                    // Use [JsonPropertyName] value if present, otherwise camelCase the C# name
                    var propName = prop.JsonName ?? StringHelpers.ToCamelCase(prop.Name);

                    // Check if nullable (Nullable<T> for value types, NRT for reference types)
                    var isNullableValue = prop.Type.IsGenericType &&
                        prop.Type.GetGenericTypeDefinition().FullName == "System.Nullable`1";
                    var isOptional = isNullableValue || prop.IsNullableRef;

                    if (isOptional)
                    {
                        // Remove " | null" if already in the mapped type (from Nullable<T>)
                        tsType = tsType.Replace(" | null", "");
                        sb.AppendLine($"  {propName}?: {tsType};");
                    }
                    else
                    {
                        sb.AppendLine($"  {propName}: {tsType};");
                    }
                }
                sb.AppendLine("}");
            }

            sb.AppendLine();
        }

        return sb.ToString();
    }

    internal static string GenerateEventsFile(List<EventDef> events, Dictionary<string, TypeDef> models)
    {
        var sb = new StringBuilder();
        sb.AppendLine(GeneratedHeader);
        sb.AppendLine("import { on, once, off, type EventCallback } from \"./runtime\";");

        // Import referenced model types
        var modelNames = new HashSet<string>();
        foreach (var evt in events)
        {
            if (evt.PayloadType.FullName != null && models.TryGetValue(evt.PayloadType.FullName, out var m))
                modelNames.Add(m.Name);
        }
        if (modelNames.Count > 0)
        {
            sb.AppendLine($"import type {{ {string.Join(", ", modelNames)} }} from \"./models\";");
        }

        sb.AppendLine();

        foreach (var evt in events)
        {
            var tsType = TypeMapper.MapTypeToTS(evt.PayloadType, models);
            var fnName = StringHelpers.ToPascalCase(evt.Name);

            // on<Type>("name", cb) wrapper
            sb.AppendLine($"/**");
            sb.AppendLine($" * Subscribe to the \"{evt.Name}\" event.");
            sb.AppendLine($" * @returns A dispose function that removes this listener.");
            sb.AppendLine($" */");
            sb.AppendLine($"export function on{fnName}(callback: EventCallback<{tsType}>): () => void {{");
            sb.AppendLine($"  return on<{tsType}>(\"{evt.Name}\", callback);");
            sb.AppendLine("}");
            sb.AppendLine();

            // once<Type>("name", cb) wrapper
            sb.AppendLine($"/**");
            sb.AppendLine($" * Subscribe to the \"{evt.Name}\" event for a single occurrence.");
            sb.AppendLine($" * @returns A dispose function that removes this listener.");
            sb.AppendLine($" */");
            sb.AppendLine($"export function once{fnName}(callback: EventCallback<{tsType}>): () => void {{");
            sb.AppendLine($"  return once<{tsType}>(\"{evt.Name}\", callback);");
            sb.AppendLine("}");
            sb.AppendLine();

            // off<Type>("name", cb) wrapper
            sb.AppendLine($"/**");
            sb.AppendLine($" * Unsubscribe a callback from the \"{evt.Name}\" event.");
            sb.AppendLine($" */");
            sb.AppendLine($"export function off{fnName}(callback: EventCallback<{tsType}>): void {{");
            sb.AppendLine($"  off<{tsType}>(\"{evt.Name}\", callback);");
            sb.AppendLine("}");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    internal static string GenerateIndexFile(List<ServiceDef> services, List<EventDef> events, Dictionary<string, TypeDef> models)
    {
        var sb = new StringBuilder();
        sb.AppendLine(GeneratedHeader);

        foreach (var svc in services)
        {
            sb.AppendLine($"export * as {svc.Name} from \"./{svc.Name}\";");
        }

        if (models.Count > 0)
        {
            sb.AppendLine("export * from \"./models\";");
        }

        if (events.Count > 0)
        {
            sb.AppendLine("export * from \"./events\";");
        }

        return sb.ToString();
    }

    internal static bool ReferencesModel(Type type, Dictionary<string, TypeDef> models)
    {
        if (type.FullName != null && models.ContainsKey(type.FullName)) return true;
        if (type.IsArray) return ReferencesModel(type.GetElementType()!, models);
        if (type.IsGenericType)
            return type.GetGenericArguments().Any(a => ReferencesModel(a, models));
        return false;
    }

    internal static HashSet<string> GetReferencedModelNames(ServiceDef service, Dictionary<string, TypeDef> models)
    {
        var names = new HashSet<string>();

        void Collect(Type type)
        {
            if (type.FullName != null && models.TryGetValue(type.FullName, out var m))
                names.Add(m.Name);
            if (type.IsArray) Collect(type.GetElementType()!);
            if (type.IsGenericType)
                foreach (var a in type.GetGenericArguments())
                    Collect(a);
        }

        foreach (var method in service.Methods)
        {
            Collect(method.ReturnType);
            foreach (var p in method.Parameters)
                Collect(p.Type);
        }

        return names;
    }
}
