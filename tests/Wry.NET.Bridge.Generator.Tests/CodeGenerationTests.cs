using Wry.NET.Bridge.Generator;
using Wry.NET.Bridge.Generator.Tests.Fixtures;

namespace Wry.NET.Bridge.Generator.Tests;

public class CodeGenerationTests
{
    #region GenerateServiceFile

    [Fact]
    public void GenerateServiceFile_HasAutoGeneratedHeader()
    {
        var service = MakeService("TestSvc", ("Greet", typeof(string), new[] { ("name", typeof(string)) }));
        var result = CodeEmitter.GenerateServiceFile(service, new Dictionary<string, TypeDef>());

        Assert.StartsWith(CodeEmitter.GeneratedHeader, result);
    }

    [Fact]
    public void GenerateServiceFile_ImportsBridgeRuntime()
    {
        var service = MakeService("TestSvc", ("Greet", typeof(string), new[] { ("name", typeof(string)) }));
        var result = CodeEmitter.GenerateServiceFile(service, new Dictionary<string, TypeDef>());

        Assert.Contains("import { call } from \"./runtime\";", result);
    }

    [Fact]
    public void GenerateServiceFile_GeneratesExportFunction()
    {
        var service = MakeService("TestSvc", ("Greet", typeof(string), new[] { ("name", typeof(string)) }));
        var result = CodeEmitter.GenerateServiceFile(service, new Dictionary<string, TypeDef>());

        Assert.Contains("export function Greet(name: string): Promise<string>", result);
        Assert.Contains("return call<string>(\"TestSvc.Greet\", name);", result);
    }

    [Fact]
    public void GenerateServiceFile_MultipleParams()
    {
        var service = MakeService("MathSvc", ("Add", typeof(int), new[] { ("a", typeof(int)), ("b", typeof(int)) }));
        var result = CodeEmitter.GenerateServiceFile(service, new Dictionary<string, TypeDef>());

        Assert.Contains("export function Add(a: number, b: number): Promise<number>", result);
        Assert.Contains("return call<number>(\"MathSvc.Add\", a, b);", result);
    }

    [Fact]
    public void GenerateServiceFile_VoidReturn()
    {
        var service = MakeService("Svc", ("DoNothing", typeof(void), Array.Empty<(string, Type)>()));
        var result = CodeEmitter.GenerateServiceFile(service, new Dictionary<string, TypeDef>());

        Assert.Contains("export function DoNothing(): Promise<void>", result);
        Assert.Contains("return call<void>(\"Svc.DoNothing\");", result);
    }

    [Fact]
    public void GenerateServiceFile_NoParams()
    {
        var service = MakeService("Svc", ("GetAll", typeof(string), Array.Empty<(string, Type)>()));
        var result = CodeEmitter.GenerateServiceFile(service, new Dictionary<string, TypeDef>());

        Assert.Contains("export function GetAll(): Promise<string>", result);
        Assert.Contains("return call<string>(\"Svc.GetAll\");", result);
    }

    [Fact]
    public void GenerateServiceFile_ImportsReferencedModels()
    {
        var models = new Dictionary<string, TypeDef>
        {
            [typeof(SimpleModel).FullName!] = new TypeDef(
                "SimpleModel", typeof(SimpleModel).FullName!,
                TypeDefKind.Interface,
                new List<PropertyDef> { new("Name", typeof(string)) }, null)
        };

        var service = MakeService("Svc", ("GetModel", typeof(SimpleModel), Array.Empty<(string, Type)>()));
        var result = CodeEmitter.GenerateServiceFile(service, models);

        Assert.Contains("import type { SimpleModel } from \"./models\";", result);
    }

    [Fact]
    public void GenerateServiceFile_ParamNamesCamelCased()
    {
        var service = MakeService("Svc", ("DoWork", typeof(string), new[] { ("FirstName", typeof(string)) }));
        var result = CodeEmitter.GenerateServiceFile(service, new Dictionary<string, TypeDef>());

        Assert.Contains("firstName: string", result);
        Assert.Contains("firstName", result);
    }

    [Fact]
    public void GenerateServiceFile_ServiceWithNoMethods_ProducesValidFile()
    {
        var service = new ServiceDef("EmptySvc", new List<MethodDef>());
        var result = CodeEmitter.GenerateServiceFile(service, new Dictionary<string, TypeDef>());

        Assert.StartsWith(CodeEmitter.GeneratedHeader, result);
        Assert.Contains("import { call } from \"./runtime\";", result);
        Assert.DoesNotContain("export function", result);
    }

    #endregion

    #region GenerateModelsFile

    [Fact]
    public void GenerateModelsFile_GeneratesInterface()
    {
        var models = new Dictionary<string, TypeDef>
        {
            ["Ns.SimpleModel"] = new TypeDef("SimpleModel", "Ns.SimpleModel", TypeDefKind.Interface,
                new List<PropertyDef>
                {
                    new("Name", typeof(string)),
                    new("Value", typeof(int))
                }, null)
        };

        var result = CodeEmitter.GenerateModelsFile(models);

        Assert.Contains("export interface SimpleModel {", result);
        Assert.Contains("  name: string;", result);
        Assert.Contains("  value: number;", result);
    }

    [Fact]
    public void GenerateModelsFile_EmptyInterface_GeneratesValidOutput()
    {
        var models = new Dictionary<string, TypeDef>
        {
            ["Ns.EmptyModel"] = new TypeDef("EmptyModel", "Ns.EmptyModel", TypeDefKind.Interface,
                new List<PropertyDef>(), null)
        };

        var result = CodeEmitter.GenerateModelsFile(models);

        Assert.Contains("export interface EmptyModel {", result);
        Assert.Contains("}", result);
    }

    [Fact]
    public void GenerateModelsFile_OptionalNullableRefProperty()
    {
        var models = new Dictionary<string, TypeDef>
        {
            ["Ns.Model"] = new TypeDef("Model", "Ns.Model", TypeDefKind.Interface,
                new List<PropertyDef>
                {
                    new("Required", typeof(string), IsNullableRef: false),
                    new("Optional", typeof(string), IsNullableRef: true)
                }, null)
        };

        var result = CodeEmitter.GenerateModelsFile(models);

        Assert.Contains("  required: string;", result);
        Assert.Contains("  optional?: string;", result);
    }

    [Fact]
    public void GenerateModelsFile_OptionalNullableValueType()
    {
        var models = new Dictionary<string, TypeDef>
        {
            ["Ns.Model"] = new TypeDef("Model", "Ns.Model", TypeDefKind.Interface,
                new List<PropertyDef>
                {
                    new("Count", typeof(int?))
                }, null)
        };

        var result = CodeEmitter.GenerateModelsFile(models);

        Assert.Contains("  count?: number;", result);
    }

    [Fact]
    public void GenerateModelsFile_ExtendsClause()
    {
        var models = new Dictionary<string, TypeDef>
        {
            ["Ns.BaseModel"] = new TypeDef("BaseModel", "Ns.BaseModel", TypeDefKind.Interface,
                new List<PropertyDef> { new("Id", typeof(string)) }, null),
            ["Ns.DerivedModel"] = new TypeDef("DerivedModel", "Ns.DerivedModel", TypeDefKind.Interface,
                new List<PropertyDef> { new("Extra", typeof(string)) }, null,
                BaseTypeName: "BaseModel")
        };

        var result = CodeEmitter.GenerateModelsFile(models);

        Assert.Contains("export interface DerivedModel extends BaseModel {", result);
        Assert.Contains("export interface BaseModel {", result);
    }

    [Fact]
    public void GenerateModelsFile_UsesJsonPropertyName()
    {
        var models = new Dictionary<string, TypeDef>
        {
            ["Ns.Model"] = new TypeDef("Model", "Ns.Model", TypeDefKind.Interface,
                new List<PropertyDef>
                {
                    new("CustomName", typeof(string), JsonName: "custom_name"),
                    new("Regular", typeof(int))
                }, null)
        };

        var result = CodeEmitter.GenerateModelsFile(models);

        Assert.Contains("  custom_name: string;", result);
        Assert.Contains("  regular: number;", result);
    }

    [Fact]
    public void GenerateModelsFile_GeneratesEnum()
    {
        var models = new Dictionary<string, TypeDef>
        {
            ["Ns.TestEnum"] = new TypeDef("TestEnum", "Ns.TestEnum", TypeDefKind.Enum, null,
                new List<EnumValueDef>
                {
                    new("None", 0),
                    new("First", 1),
                    new("Second", 2)
                })
        };

        var result = CodeEmitter.GenerateModelsFile(models);

        Assert.Contains("export enum TestEnum {", result);
        Assert.Contains("  None = 0,", result);
        Assert.Contains("  First = 1,", result);
        Assert.Contains("  Second = 2,", result);
    }

    [Fact]
    public void GenerateModelsFile_HasAutoGeneratedHeader()
    {
        var models = new Dictionary<string, TypeDef>
        {
            ["Ns.M"] = new TypeDef("M", "Ns.M", TypeDefKind.Interface,
                new List<PropertyDef>(), null)
        };

        var result = CodeEmitter.GenerateModelsFile(models);

        Assert.StartsWith(CodeEmitter.GeneratedHeader, result);
    }

    #endregion

    #region GenerateEventsFile

    [Fact]
    public void GenerateEventsFile_GeneratesOnHelper()
    {
        var (events, models) = MakeEventsAndModels();
        var result = CodeEmitter.GenerateEventsFile(events, models);

        Assert.Contains("export function onTestEvent(callback: EventCallback<TestEvent>): () => void {", result);
        Assert.Contains("return on<TestEvent>(\"test_event\", callback);", result);
    }

    [Fact]
    public void GenerateEventsFile_GeneratesOnceHelper()
    {
        var (events, models) = MakeEventsAndModels();
        var result = CodeEmitter.GenerateEventsFile(events, models);

        Assert.Contains("export function onceTestEvent(callback: EventCallback<TestEvent>): () => void {", result);
        Assert.Contains("return once<TestEvent>(\"test_event\", callback);", result);
    }

    [Fact]
    public void GenerateEventsFile_GeneratesOffHelper()
    {
        var (events, models) = MakeEventsAndModels();
        var result = CodeEmitter.GenerateEventsFile(events, models);

        Assert.Contains("export function offTestEvent(callback: EventCallback<TestEvent>): void {", result);
        Assert.Contains("off<TestEvent>(\"test_event\", callback);", result);
    }

    [Fact]
    public void GenerateEventsFile_ImportsRuntimeFunctions()
    {
        var (events, models) = MakeEventsAndModels();
        var result = CodeEmitter.GenerateEventsFile(events, models);

        Assert.Contains("import { on, once, off, type EventCallback } from \"./runtime\";", result);
    }

    [Fact]
    public void GenerateEventsFile_ImportsModelTypes()
    {
        var (events, models) = MakeEventsAndModels();
        var result = CodeEmitter.GenerateEventsFile(events, models);

        Assert.Contains("import type { TestEvent } from \"./models\";", result);
    }

    [Fact]
    public void GenerateEventsFile_HasJsDocComments()
    {
        var (events, models) = MakeEventsAndModels();
        var result = CodeEmitter.GenerateEventsFile(events, models);

        Assert.Contains("* Subscribe to the \"test_event\" event.", result);
        Assert.Contains("* @returns A dispose function that removes this listener.", result);
    }

    [Fact]
    public void GenerateEventsFile_SnakeCaseEventName_PascalCasedFunction()
    {
        // "test_event" -> onTestEvent, onceTestEvent, offTestEvent
        var (events, models) = MakeEventsAndModels();
        var result = CodeEmitter.GenerateEventsFile(events, models);

        Assert.Contains("onTestEvent", result);
        Assert.Contains("onceTestEvent", result);
        Assert.Contains("offTestEvent", result);
    }

    [Fact]
    public void GenerateEventsFile_HasAutoGeneratedHeader()
    {
        var (events, models) = MakeEventsAndModels();
        var result = CodeEmitter.GenerateEventsFile(events, models);

        Assert.StartsWith(CodeEmitter.GeneratedHeader, result);
    }

    #endregion

    #region GenerateIndexFile

    [Fact]
    public void GenerateIndexFile_ExportsServices()
    {
        var services = new List<ServiceDef>
        {
            new("GreetService", new List<MethodDef>()),
            new("MathService", new List<MethodDef>())
        };

        var result = CodeEmitter.GenerateIndexFile(services, new List<EventDef>(), new Dictionary<string, TypeDef>());

        Assert.Contains("export * as GreetService from \"./GreetService\";", result);
        Assert.Contains("export * as MathService from \"./MathService\";", result);
    }

    [Fact]
    public void GenerateIndexFile_ExportsModels_WhenPresent()
    {
        var services = new List<ServiceDef>();
        var models = new Dictionary<string, TypeDef>
        {
            ["Ns.M"] = new TypeDef("M", "Ns.M", TypeDefKind.Interface, new List<PropertyDef>(), null)
        };

        var result = CodeEmitter.GenerateIndexFile(services, new List<EventDef>(), models);

        Assert.Contains("export * from \"./models\";", result);
    }

    [Fact]
    public void GenerateIndexFile_SkipsModels_WhenEmpty()
    {
        var services = new List<ServiceDef>
        {
            new("Svc", new List<MethodDef>())
        };

        var result = CodeEmitter.GenerateIndexFile(services, new List<EventDef>(), new Dictionary<string, TypeDef>());

        Assert.DoesNotContain("models", result);
    }

    [Fact]
    public void GenerateIndexFile_ExportsEvents_WhenPresent()
    {
        var events = new List<EventDef>
        {
            new("test", typeof(TestEvent))
        };

        var result = CodeEmitter.GenerateIndexFile(new List<ServiceDef>(), events, new Dictionary<string, TypeDef>());

        Assert.Contains("export * from \"./events\";", result);
    }

    [Fact]
    public void GenerateIndexFile_SkipsEvents_WhenEmpty()
    {
        var result = CodeEmitter.GenerateIndexFile(new List<ServiceDef>(), new List<EventDef>(), new Dictionary<string, TypeDef>());

        Assert.DoesNotContain("events", result);
    }

    [Fact]
    public void GenerateIndexFile_HasAutoGeneratedHeader()
    {
        var result = CodeEmitter.GenerateIndexFile(new List<ServiceDef>(), new List<EventDef>(), new Dictionary<string, TypeDef>());

        Assert.StartsWith(CodeEmitter.GeneratedHeader, result);
    }

    #endregion

    #region Helpers

    private static ServiceDef MakeService(string name, params (string MethodName, Type ReturnType, (string Name, Type Type)[] Params)[] methods)
    {
        var methodDefs = methods.Select(m => new MethodDef(
            m.MethodName,
            m.Params.Select(p => new ParamDef(p.Name, p.Type)).ToList(),
            m.ReturnType,
            IsAsync: false
        )).ToList();

        return new ServiceDef(name, methodDefs);
    }

    private static (List<EventDef> Events, Dictionary<string, TypeDef> Models) MakeEventsAndModels()
    {
        var events = new List<EventDef>
        {
            new("test_event", typeof(TestEvent))
        };

        var models = new Dictionary<string, TypeDef>
        {
            [typeof(TestEvent).FullName!] = new TypeDef(
                "TestEvent", typeof(TestEvent).FullName!,
                TypeDefKind.Interface,
                new List<PropertyDef>
                {
                    new("Count", typeof(int)),
                    new("Message", typeof(string))
                }, null)
        };

        return (events, models);
    }

    #endregion
}
